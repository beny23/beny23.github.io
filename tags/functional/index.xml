<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>functional on Tales about Software Engineering</title><link>https://beny23.github.io/tags/functional/</link><description>Recent content in functional on Tales about Software Engineering</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><copyright>Software Design Systems</copyright><lastBuildDate>Sat, 02 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://beny23.github.io/tags/functional/index.xml" rel="self" type="application/rss+xml"/><item><title>AI-dvent of Code 2023: Day 1</title><link>https://beny23.github.io/posts/advent_of_code_2023_day_1_ai_experiments/</link><pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2023_day_1_ai_experiments/</guid><description>So it is that time of the year again. Advent of Code is back. Yey! This means I get to try to look at a new language again. This time, why not Kotlin? But as an extra challenge, I thought why not see how the vaunted LLMs would help. Is AI really the accelerator that would elevate a mere developer to a rockstar ninja (whatever that is)?
I have to add that I am a bit of an AI sceptic and keep saying that</description></item><item><title>Functional programming in MongoDB</title><link>https://beny23.github.io/posts/functional_mongo_aggregation/</link><pubDate>Tue, 06 Jun 2023 21:32:00 +0000</pubDate><guid>https://beny23.github.io/posts/functional_mongo_aggregation/</guid><description>In this post I am looking at using the mongo aggregation pipeline in non-trivial ways. In fact, once I had done what I wanted to do I looked back at the result and discovered that a bit of an idea of functional programming helped me achieve what I wanted to do.
But back to the beginning: I was looking at deployment events which we&amp;rsquo;d captured in a mongo collection:
{ &amp;quot;environment&amp;quot; : &amp;quot;production&amp;quot;, &amp;quot;serviceName&amp;quot; : &amp;quot;platform-status-frontend&amp;quot;, &amp;quot;version&amp;quot; : &amp;quot;0.</description></item><item><title>Advent of code 2021: Day 22</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_22/</link><pubDate>Thu, 13 Jan 2022 00:44:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_22/</guid><description>Day 22 of Advent of Code 2021 was all about cubes. The problem statement provided us with coordinates of cubes and an &amp;ldquo;on&amp;rdquo; or &amp;ldquo;off&amp;rdquo; instructions. These instructions needed to be carried out in order. The first part of the problem was deceptively simple. So much so that I didn&amp;rsquo;t go for the &amp;ldquo;obvious&amp;rdquo; solution initially because I thought it wouldn&amp;rsquo;t scale. As it happened I ended up implementing it anyway as my optimised approach wasn&amp;rsquo;t working because I made a simple mistake.</description></item><item><title>Advent of code 2021: Day 21</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_21/</link><pubDate>Sat, 08 Jan 2022 23:44:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_21/</guid><description>On Day 21 of Advent of Code 2021 we played Dirac Dice! And part one felt way too easy to solve, but I needed have worried because part two we were asked to solve a limited multiverse problem. And without a quantum computer!
The problem The problem was described as follows.
Two players are playing a game with three dice Each starts on a different position of the board The board is circular and has 10 numbered positions Players take it in turn to roll three dice A player moves forward by the sum of those three dice Once the complete their move, they add as many points to their score as indicated by the board position First to 1000 points wins The dice are deterministic, meaning that they roll 1, 2, 3, &amp;hellip;, 100, 1, 2, &amp;hellip; Part One To start with, I created some types:</description></item><item><title>Advent of code 2021: Day 20</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_20/</link><pubDate>Thu, 06 Jan 2022 22:14:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_20/</guid><description>Hmpf. It&amp;rsquo;s now January and I&amp;rsquo;m still doing Advent. Still, I was determine to push ahead. Then I got stuck good and proper on Day 19 - though to be fair the whole Log4shell dumpster fire was taking up a lot of time, so I decided to skip it for now. Day 20 of Advent of Code 2021 was all about transforming images. What made it slightly more complicated was the fact that the images were nominally of infinite size.</description></item><item><title>Advent of code 2021: Day 18</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_18/</link><pubDate>Wed, 29 Dec 2021 02:14:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_18/</guid><description>Day 18 of Advent of Code 2021 took rather a long time to get right. Half of the problem was that there were a couple of gotchas in the requirements and the choice of data structure hugely impacted how easy it was to come up with a solution. Just like Day 17 I was using TDD and this helped me root out some blind alleys nicely.
The problem The story was roughly as follows: In order to continue on the Advent of Code submarine journey, we had to solve snailfish number problems.</description></item><item><title>Advent of code 2021: Day 17</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_17/</link><pubDate>Mon, 20 Dec 2021 17:14:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_17/</guid><description>On day 17 of Advent of Code 2021, I did something that I should have really done from the start: Write tests first. My excuse so far has been that I wasn&amp;rsquo;t familiar with Haskell yet and other such lame excuses. As a software engineer, I should know better. TDD doesn&amp;rsquo;t slow me down, it makes things faster. The last straw - if you like - was when I was writing up my exploits from Day 16 and I thought there really is no excuse for not testing these parser combinators individually.</description></item><item><title>Advent of code 2021: Day 16</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_16/</link><pubDate>Mon, 20 Dec 2021 00:14:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_16/</guid><description>For day 16 Advent of Code 2021, it was all about monadic parser combinators (whatever they are)! Just like Day 15, this one took me a lot longer to complete than I had wanted, this time it was all about learning Haskell&amp;rsquo;s approach to parsing text.
According to the story, we had to decode a message in a custom binary format, the Buoyancy Interchange Transmission System (BITS). BITS is a message format that encodes both literal values and operations.</description></item><item><title>Advent of code 2021: Day 15</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_15/</link><pubDate>Sun, 19 Dec 2021 17:28:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_15/</guid><description>Advent of Code 2021 day 15 took us back to the 2-dimensional maps we first encountered on Day 11 and Day 9. We had to parse a map again, and this time we had to find the shortest path from the top left to the bottom right. This was the first time when a homespun algorithm just did not cut the mustard, and I had to wrack my brain (i.e. use Google) to do a bit of algorithm research.</description></item><item><title>Advent of code 2021: Day 14</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_14/</link><pubDate>Wed, 15 Dec 2021 01:28:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_14/</guid><description>After Advent of Code 2021 transparent origami on Day 13 with more output than just a number, for Day 14 it was back to more standard processing with exponential complexity. Interestingly in part 1 I initially started going down the route of not trying to brute forcing it, got almost there but tangled myself in some logic, so I decided to &amp;ldquo;sod it, I&amp;rsquo;ll just brute force it&amp;rdquo; only to then throw the brute force solution away again as soon as I got to part 2.</description></item><item><title>Advent of code 2021: Day 13</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_13/</link><pubDate>Tue, 14 Dec 2021 01:15:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_13/</guid><description>On day 13 of Advent of Code 2021 we had to do the impossible. We were folding a transparent piece of paper 12 times. Surely it isn&amp;rsquo;t possible to fold paper more than 7 times, but we also have to remember that we&amp;rsquo;re in a Santa submarine!
The aim of the puzzle is to get a code by folding over a transparent sheet of paper which has got dots dotted all over.</description></item><item><title>Advent of code 2021: Day 12</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_12/</link><pubDate>Mon, 13 Dec 2021 00:11:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_12/</guid><description>For Advent of Code 2021 day 12 it took me a while to get going though for reasons unrelated to coding, Norovirus is not pleasant! So when I finally did the puzzle, I didn&amp;rsquo;t find it as difficult as I thought it would be based on some of the messages on the #adventofcode channel. The puzzle started with
With your submarine&amp;rsquo;s subterranean subsystems subsisting suboptimally
This deserves a medal in itself.</description></item><item><title>Advent of code 2021: Day 11</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_11/</link><pubDate>Sat, 11 Dec 2021 15:00:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_11/</guid><description>Advent of Code 2021 day 11 felt a little bit like a repeat of Day 9. In both cases, we got a 2-dimensional map with single digit values. In case of day 9 it was a height map, this time round we&amp;rsquo;ve got a 10x10 grid of bioluminescent Octopi. Each of those critters has an energy level that increases each round. Once that level goes past 9, it lets off a flash, which then imparts extra energy into the surrounding 8-legged creatures.</description></item><item><title>Advent of code 2021: Day 10</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_10/</link><pubDate>Fri, 10 Dec 2021 23:30:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_10/</guid><description>Day 10 of Advent of Code 2021 was all about mismatched brackets. And I think Haskell did rather well on this as I found the expressiveness arrived at a really concise solution. We&amp;rsquo;re still in our Advent submarine and after mapping the floor on Day 9, we now discover lots of syntax errors in the submarine navigation system.
The problem This puzzle was all about matching brackets, the input was like this:</description></item><item><title>Advent of code 2021: Day 9</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_9/</link><pubDate>Thu, 09 Dec 2021 14:00:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_9/</guid><description>On day 9 of Advent of Code 2021 I arrived at two different solutions for parts one and two. That is to say the approach I took in part one turned out to be useless for part two, though I&amp;rsquo;m pleased with both solutions. Unlike yesterday&amp;rsquo;s which got a bit convoluted (Day 8).
The problem This puzzle was all about looking at a height map and finding the lowest points. The input would look like so:</description></item><item><title>Advent of code 2021: Day 8</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_8/</link><pubDate>Wed, 08 Dec 2021 13:00:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_8/</guid><description>On day 8 Advent of Code 2021 adventure, part 1 lulled me into a false sense of security. It took longer to read the instructions than implementing the code. But then part 2 was back with a vengeance. Admittedly it would have been so much easier if I slowed down a bit and actually counted carefully. As it happened it was a good reminder that &amp;ldquo;more haste, less speed&amp;rdquo; applies to programming very much.</description></item><item><title>Advent of code 2021: Day 7</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_7/</link><pubDate>Tue, 07 Dec 2021 09:00:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_7/</guid><description>On the 7th day of the submarine Advent of Code 2021 adventure, I felt like the problem was getting a bit easier than it had been of late. If anything I felt a touch suspicious on whether I had been missing anything. In previous days I had to reframe the problem statement a bit to make it efficient (Day 4, Day 5 and Day 5). Either that or I&amp;rsquo;m starting to feel more comfortable with Haskell.</description></item><item><title>Advent of code 2021: Day 6</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_6/</link><pubDate>Mon, 06 Dec 2021 13:46:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_6/</guid><description>On the next day of Advent of Code 2021 there were two approaches to solving the problem. Brute force and ignorance, and stopping to think about it. After finding out that Haskell often forces me to having a think first on Day 4 and Day 5, I was looking forward to
The problem This puzzle was all about lanternfish population - yes there was a submarine theme to this year!</description></item><item><title>Advent of code 2021: Day 5</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_5/</link><pubDate>Mon, 06 Dec 2021 12:48:32 +0000</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_5/</guid><description>Following from my efforts on Day 4 of Advent of Code 2021 I was encouraged to try writing up more of my attempts to teach myself Haskell while having fun trying to solve puzzles.
The problem The exercise was concerned with drawing lines on a grid and finding intersections:
An entry like 1,1 -&amp;gt; 1,3 covers points 1,1, 1,2, and 1,3. An entry like 9,7 -&amp;gt; 7,7 covers points 9,7, 8,7, and 7,7.</description></item><item><title>Advent of code 2021: Day 4</title><link>https://beny23.github.io/posts/advent_of_code_2021_day_4/</link><pubDate>Sun, 05 Dec 2021 08:48:32 +0100</pubDate><guid>https://beny23.github.io/posts/advent_of_code_2021_day_4/</guid><description>For Advent of Code 2021 rather than just thinking &amp;ldquo;Hey, what a good idea - I should give that a go&amp;rdquo; and then promptly forgetting about it, I thought it would be a good opportunity to explore Haskell a bit more.
On day 4 - when I started scratching my head for a bit - I discovered one interesting aspect about a functionally pure approach &amp;ldquo;forced&amp;rdquo; on me by Haskell.</description></item><item><title>Fizzbuzz without if clauses</title><link>https://beny23.github.io/posts/fizzbuzz_without_ifs/</link><pubDate>Thu, 04 Mar 2021 08:44:19 +0000</pubDate><guid>https://beny23.github.io/posts/fizzbuzz_without_ifs/</guid><description>In this writing I aim to complete a Fizzbuzz without if statements, conditionals, pattern matching or even using modulus calculations. And if that isn&amp;rsquo;t enough I thought I&amp;rsquo;d use the opportunity to explore Haskell.
The idea originated in the Friday lunchtime &amp;ldquo;Curry Club&amp;rdquo; at HMRC Digital where a few like-minded software engineers are getting together to teach themselves Haskell. (For those not in on the joke, the language is named after the logician Haskell Curry).</description></item></channel></rss>